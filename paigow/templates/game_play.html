{% extends "paigow/base_site.html" %}
{% load static %}{% load paigow_extras %}

{% block extra-stylesheet %}
  <link rel="stylesheet" type="text/css" href="{% static "css/pgtile.css" %}" />
{% endblock %}

{% block content_title %}<p><span class="lead"><strong>{{ game.name }}</strong></span>{% endblock %}

{% block header-javascript %}
  <script language="javascript">

    //  Convenience functions for getting ids etc.
    function set_num_of_button( button )  { return parseInt(button.id.substring(0, 1)); }      // first char

    function set_num_of_set( pgset )
    {
      var parent = $(pgset).parent();
      var jqsets = parent.find(".pgset");
      return jqsets.index( pgset ) + 1;   // 1-based
    }

    function jqset_of_num( set_num )
    {
      var jqdeal = $("#paigow321-deal");
      var jqsets = jqdeal.find(".pgset");
      return $(jqsets[ set_num-1 ] );      // 1-based
      //return $( "#" + set_id_of_num( set_num ) );
    }

    function jqset_of_tile( pgtile ) { return $(pgtile).parent(); }

    function set_num_of_tile( pgtile )  { return set_num_of_set( jqset_of_tile(pgtile)[0] ); }

    function tiles_of_jqset( jqset ) { return jqset.find('.pgtile-div'); }

    function tile_num( pgtile ) { return tiles_of_jqset( jqset_of_tile(pgtile) ).index( pgtile ); }    // index in tile list

    function jqtile_of_nums( set_num, tile_num ) { return $(tiles_of_jqset( jqset_of_num( set_num ) )[tile_num] ); }

    function set_id( pgtile) { return "pgset-div-" + set_num_of_tile( pgtile ); }

    function set_id_of_num( set_num ) { return "pgset-div-" + set_num; }

    function set_class_of_num( set_num ) { return "pgset-{{ pgtile_size }}-" + set_num; }

    function tile_chars_of_jqset( jqset ) {
      var tiles = tiles_of_jqset( jqset );
      return  "" +
              tiles[0].getAttribute('tile_id') + 
              tiles[1].getAttribute('tile_id') + 
              tiles[2].getAttribute('tile_id') + 
              tiles[3].getAttribute('tile_id');
    }

    //  Switch class and ID convenience.
    function change_class_and_id( jqobj, old_class, new_class, new_id )
    {
        jqobj.removeClass( old_class );
        jqobj.addClass( new_class );
        jqobj.attr( "id", new_id );
    }

    //  Drag/drop convenience functions
    function disable_drop( jqobj )
    {
      jqobj.droppable( {
          disabled: true,
          drop: undefined
        } );
    }
    
    function lefts_of_jqset( jq_set )
    {
      var lefts = new Array(4);
      var tiles = tiles_of_jqset( jq_set );
      for ( var i = 0; i < 4; i++ )
        lefts[i] = $(tiles[i]).offset().left;
      return lefts;
    }

    function drag_tile_start( pgtile, event, ui )
    {
      //  Get the set number from the tile, and make only that set droppable, and
      //  only allow dropping of tiles.
      var jq_set = jqset_of_tile( pgtile );
      jq_set.droppable( {
          disabled: false,
          drop: function(event, ui) { drop_tile( this, event, ui ); }
        } );
      jq_set.data( "orig", $(pgtile).position() );

      //  Put the tile on top of the other tiles.
      $(pgtile).css( "z-index", parseInt($(pgtile).css("z-index")) + 1 );

      //  Add to the droppable the data of the topleft of each of the tiles.
      jq_set.data( "lefts", lefts_of_jqset( jq_set ) );
    }
    
    function drag_tile_stop( pgtile, event, ui )
    {
      //  Get the set number from the tile, and undo setting it droppable
      //  and get rid of the drop function.
      var jq_set = jqset_of_tile( pgtile );
      disable_drop( jq_set );
      jq_set.removeData( "lefts" );
      jq_set.removeData( "orig" );

      //  Put the tile in the same plane as the others
      $(pgtile).css( "z-index", parseInt($(pgtile).css("z-index")) - 1 );

    }

    function drop_tile( pgset, event, ui )
    {
      var jqset = $(pgset);

      //  Figure out where the new position is by looking at the lefts array.
      var lefts = jqset.data( "lefts" );

      //  Testing has shown that this is the difference from the original location of the tile.
      var pgtile = ui.draggable[0];
      var source_index = tile_num( pgtile );
      var new_left = ui.offset.left;

      //  Figure out where we should drop it.  There are FIVE possible locations,
      //  from left of the leftmost tile to right of the rightmost tile.  For
      //  moving to the left, only the first four make sense.  For moving to the
      //  right, only the last four make sense.
      var dest_index = 4;
      for ( i = 0; i < 4; i++ )
      {
        if ( new_left < lefts[i] )
        {
          dest_index = i;
          break;
        }
      }

      var orig_dest_index = dest_index;
      var is_moving_left = (dest_index <= source_index);

      //  If we're moving right, then the dest index is actually
      //  one less (zero doesn't make sense, but moving to "1" is
      //  moving to zero).
      if ( !is_moving_left) dest_index--;

      //  If we're not moving it, forget it: returning 'false' will stop the drag.
      if ( dest_index == source_index )
      {
        ui.draggable.animate( {
          left: jqset.data("orig").left, top: jqset.data("orig").top
        } );
        return false;
      }

      //  Calculate the new index for each of the four current tiles.
      new_indices = new Array(4);
      var i;
      for ( i = 0; i < 4; i++ )
      {
        var new_index = i;
        if ( i == source_index )
        {
          //  Is the source tile: move to dest.
          new_index = dest_index;
        }
        else if ( i < dest_index && i < source_index )
        {
          //  To the left of all the action: leave it alone.
        }
        else if ( is_moving_left && (i >= dest_index && i < source_index ))
        {
          //  tile inserted before us: move right (index up)
          new_index = i + 1;
        }
        else if ( is_moving_left )
        {
          //  Must be to right of all the action, leave alone.
        }
        else if ( i <= dest_index && i > source_index )
        {
          //  Moving to the right, between: slide left.
          new_index = i - 1;
        }

        new_indices[i] = new_index;
      }

      //  Move the tiles on the screen
      var tiles = tiles_of_jqset( jqset_of_tile( pgtile ) );
      for ( i = 0; i < 4; i++ )
      {
        new_index = new_indices[i];
        $(tiles[i]).animate( {
          left: "" + lefts[new_index] - jqset.offset().left + "px", top: "0px"
        } );
      }

      //  Get the tile and move it, in the DOM, to its place in the list.
      //  We use dest_index to find out if we're moving it to the end
      //  (only moving left), but orig_dest_index to do the final move.
      var jqmoved = $(tiles[source_index]);
      if ( dest_index == 3 )
      {
        jqset.append(jqmoved);
      }
      else
      {
        jqmoved.insertBefore(tiles[orig_dest_index]);
      }

      update_hand_labels( jqset_of_tile( pgtile ) );
    }
    
    function update_hand_labels( jqset )
    {
      //  Time to update the labels: send a request to get the new values.
      var new_tiles = tiles_of_jqset( jqset );
      $.ajax( {
        url: "/paigow/data/hand/",
        context: jqset[0],
        data: {
            hand: tile_chars_of_jqset( jqset )
        },
        success: function( data, textStatus, jqXHR ) { return set_hand_label( this, data, textStatus, jqXHR ); },
        error: function( data, textStatus, jqXHR ) { return set_hand_label( this, "<error>|<errr>", "error", undefined ); }
      } );
    }

    //  We got a response from our request for the new values for our hands, called
    //  by ajax in drop_tiles above.
    function set_hand_label( context, data, textStatus, jqXHR )
    {
      //  The response is the two labels, with a vertical bar in between.
      var hands = data.split("|");

      //  The context is the set div we were dragging in.
      var set_num = set_num_of_set( context );

      //  Get the labels for this div, and assign by index.
      var labels = $(context).find(".pghand-labels");
      $(labels[0]).text( hands[0] );
      $(labels[1]).text( hands[1] );
    }

    //  Click the up or down button for a set
    function switch_click( button )
    {
      //  Get the set number: it's the first char of the id.
      var source_set_num = set_num_of_button( button );

      //  Get whether we're moving it up or down.
      var dest_set_num = source_set_num + 1

      //  Get the jq objects of the two sets
      var source = jqset_of_num( source_set_num );
      var dest = jqset_of_num( dest_set_num );

      //  Switch the location of the two sets
      var source_top = source.position().top;
      var dest_top = dest.position().top;
      source.animate( { top: dest_top } );
      dest.animate( { top: source_top } );

      //  Reorder the sets within the deal.
      if ( dest_set_num == 3 )     // goes to the end (1-based, remember)
      {
        $(source.parent()).append( source );
      }
      else
      {
        source.insertAfter(dest);
      }
    }

    // Poll the server for the opponent's state
    function get_opponent_state()
    {
      get_xxx_state( "opponent", true )
    }
    
    // Ask the server for the player's state (we know it, but to have only one place
    // where the strings are used, we have the server give it to us.
    function get_player_state()
    {
      get_xxx_state( "player", false )
    }

    function get_xxx_state( label, keep_polling )
    {
      $.ajax( {
        url: "/paigow/data/game/{{ game.id }}/" + label + "_state",
        context: document.body,
        success: function( data, textStatus, jqXHR ) { return set_opponent_state( this, data, textStatus, jqXHR, label, keep_polling ); },
        error: function( data, textStatus, jqXHR ) { return set_opponent_state( this, "<error>|<error>", "error", undefined, label, keep_polling ); }
      } );
    }

    function set_opponent_state( context, data, textStatus, jqXHR, label, poll_again )
    {
        //  The return value is the text that goes into the state.  If there
        //  is some sort of error, show "<error>". We know it's the state because
        //  it starts with "|".
        var state = "unknown"
        if ( data[0] == '|' )
        {
          var state_array = data.split("|");
          state = state_array[1];
        }
        $("#state_" + label).text( state );

        //  Do it again in 5 seconds
        if ( poll_again )
        {
          setTimeout( get_opponent_state, 5000 );
        }
    }
    
    function tiles_are_set()
    {
      // User has hit "Tiles are Set" so tell the server of our state.
      $.ajax( {
        url: "/paigow/data/game/{{ game.id }}/tiles_are_set",
        context: document.body,
        data: {
            set1: tile_chars_of_jqset( jqset_of_num( 1 ) ),
            set2: tile_chars_of_jqset( jqset_of_num( 2 ) ),
            set3: tile_chars_of_jqset( jqset_of_num( 3 ) )
        },
        success: function( data, textStatus, jqXHR ) { return tiles_are_set_success( this, data, textStatus, jqXHR ); },
        //error: function( data, textStatus, jqXHR ) { return set_hand_label( this, "<error>|<errr>", "error", undefined ); }
      } );

    }
    
    function tiles_are_set_success( context, data, textStatus, jqXHR )
    {
      // ajax call for setting tiles has returned so the server knows our state
      // is new, so we can get it.
      get_player_state();
    }
    
    var current_player_state = "setting tiles";
    function preview_hands()
    {
      if ( current_player_state == "setting tiles" )
      {
          $.ajax( {
            url: "/paigow/data/game/{{ game.id }}/preview_hands",
            context: document.body,
            data: {
                set1: tile_chars_of_jqset( jqset_of_num( 1 ) ),
                set2: tile_chars_of_jqset( jqset_of_num( 2 ) ),
                set3: tile_chars_of_jqset( jqset_of_num( 3 ) )
            },
            success: function( data, textStatus, jqXHR ) { return set_all_tiles_for_preview( this, data, textStatus, jqXHR ); },
          } );
      }
      else
      {
        // we are un-previewing: no need to move tiles around, just rotate the
        // low hands back (the global current_player_state tells this function
        // how it should rotate).
        for ( var s = 1; s <= 3; s++ )
          rotate_low_hands_for_preview( s );
      }
    }
    
    //  Switch two tiles' positions, animating it.
    function switch_tiles( jqset, index_src, index_dst, lefts )
    {
        var tiles = tiles_of_jqset( jqset )
        $(tiles[index_src]).animate( { left: "" + lefts[index_dst] - jqset.offset().left + "px", top: "0px" } );
        $(tiles[index_dst]).animate( { left: "" + lefts[index_src] - jqset.offset().left + "px", top: "0px" } );
        if ( (index_src + 1) == index_dst )
            $(tiles[index_src]).insertAfter( $(tiles[index_dst]) );
        else
        {
            $(tiles[index_dst]).insertBefore( $(tiles[index_src]) );
            $(tiles[index_src]).insertAfter( $(tiles[index_dst-1]) );
        }
    }
    
    function set_all_tiles_for_preview( context, data, textStatus, jqXRH )
    {
      if ( current_player_state == "setting tiles" )
      {
        // The return values show where the tiles should appear if the dealer
        // turned over our set hands: high hand upright to the left, and
        // low hand horizontal to the right.
        var reorder_array = data.split("|");
        for ( var r = 1; r <= 3; r++ )
          reorder_tiles_in_hands( r, reorder_array[r] );
      }
    }

    function reorder_tiles_in_hands( set_num, reorder_str )
    {
      var jqset = jqset_of_num( set_num );
      var lefts = lefts_of_jqset( jqset );

      // We re-order the tiles in each hand first; we can tell
      // if we need to reorder by the relative location of the index
      // returned by the server.
      if (reorder_str.indexOf('1') < reorder_str.indexOf('0'))
        switch_tiles( jqset, 0, 1, lefts );
      if (reorder_str.indexOf('3') < reorder_str.indexOf('2'))
        switch_tiles( jqset, 2, 3, lefts );

      // Something about simultaneous animation of the same tiles
      // doesn't work.  The default duration is 400 ms, so wait
      // 500 msec and then reorder the hands if necessary.
      setTimeout( function() { reorder_hands_in_set( set_num, reorder_str ); }, 500 );
    }

    function reorder_hands_in_set( set_num, reorder_str )
    {
      var jqset = jqset_of_num( set_num );
      var lefts = lefts_of_jqset( jqset );

      // Now re-order the hands.
      if (reorder_str.indexOf('3') < reorder_str.indexOf('0'))
      {
        switch_tiles( jqset, 0, 2, lefts );
        switch_tiles( jqset, 1, 3, lefts );
        update_hand_labels( jqset );
      }
      
      // After the reordering, we'll rotate.
      setTimeout( function() { rotate_low_hands_for_preview( set_num ) }, 500 );
    }
    
    function restore_draggable_to_tiles( jqtile )
    {
       $(".pgtile-div-player").each( function() { $(this).draggable( "enable" ) } );
    }

    function set_new_preview_state()
    {
      
      var new_text;
      
      if ( current_player_state == "setting tiles" )
      {
        current_player_state = "previewing hands";
        new_text = "Un-preview Hands";
        $("#tiles-are-set-button").removeClass("disabled");

        // Make sure all tile are no longer draggable; this will be
        // restored if the user un-previews
        $(".pgtile-div-player").each( function() { $(this).draggable( "disable" ) } );
      }
      else
      {
        new_text = "Preview Hands";
        current_player_state = "setting tiles";
        $("#tiles-are-set-button").addClass("disabled");

        setTimeout( restore_draggable_to_tiles, 1000 );
      }
    
      $("#preview-hands-button").text( new_text );

    }
    
    function rotate_low_hands_for_preview( set_num )
    {
      rotate_low_hand_in_set( set_num );

      // finish it all up... this is skanky.  After the third set,
      // we have to restore draggable or whatever needs to be done
      // after all the animation.
      if ( set_num == 3 )
        set_new_preview_state();
    }

    function rotate_low_hand_in_set( set_num )
    {
      // Rotage the second two tiles as well.
      var jqtile2 = jqtile_of_nums( set_num, 2 );
      var jqtile3 = jqtile_of_nums( set_num, 3 );

      if ( current_player_state == "setting tiles" )
      {
        rotate_for_preview( jqtile2, '+=20px', '-=25px', true );
        rotate_for_preview( jqtile3, '-=35px', '+=30px', true );
      }
      else
      {
        rotate_for_preview( jqtile2, '-=20px', '+=25px', false );
        rotate_for_preview( jqtile3, '+=35px', '-=30px', false );
      }
    }

    function rotate_for_preview( jqtile, left_amt, top_amt, rotating )
    {
      jqtile.addClass("pgtile-ease-in-out");
      if ( rotating )
      {
        jqtile.addClass("rotated");
        jqtile.removeClass("unrotated");
      }
      else
      {
        jqtile.addClass("unrotated");
        jqtile.removeClass("rotated");
      }

      //  We have to wait until the rotation is finished before moving it,
      // or they'll interfere with each other.
      setTimeout( function() { finish_unpreview( jqtile, left_amt, top_amt, rotating ); }, 500 );
    }
    
    function finish_unpreview( jqtile, left_amt, top_amt, rotating )
    {
      // If we had previewed, we had added this class an it effects
      // the animate motion.  Make sure it's gone
      jqtile.removeClass("pgtile-ease-in-out");
      
      // This class makes it un-draggable for some reason.  Remove it too.
      if (!rotating)
        jqtile.removeClass("unrotated");
  
      // Now we want to move it to the right place
      jqtile.animate( { left: left_amt, top: top_amt } );
    }

  </script>
{% endblock %}

{% block jquery-doc-ready %}

  //  Fade the sets in, in order.  These set classes don't have sizes so we can use them as
  //  generic sets.  Note they are 1,2,3 rather than 0-based so the index is the same as
  //  the number of points assigned (for simplicity).
  $("#pgset-div-1-player").fadeIn( 500);
  $("#pgset-div-2-player").fadeIn(1000);
  $("#pgset-div-3-player").fadeIn(1500);
  
  $("#pgset-div-1-opponent").fadeIn(2000);
  $("#pgset-div-2-opponent").fadeIn(1500);
  $("#pgset-div-3-opponent").fadeIn(3000);
  
  //  The tiles are draggable
  //  TBD: put this in pgtile.html, how to do that while including it several times
  $(".pgtile-div-player").draggable( {
      //helper: "clone",
      revert: "invalid",
      start: function( event, ui ) { drag_tile_start( this, event, ui ); },
      stop: function( event, ui ) { drag_tile_stop( this, event, ui ); }
    } );

  //  The divs holding the sets will be droppable, but only accept tiles.
  //  They are disabled until a tile is dragged, and only the appropriate
  //  set or sets are un-disabled.
  $(".pgset-player").droppable( { 
      disabled: true
    } );

  //$(".paigow321-deal").droppable( {
  //    disabled: true
  //  } );

  // Make the switch buttons active
  $(".pgset-button-switch").click( function( button ) { return switch_click( this ); } );
  
  // Make the "tiles-are-set" button active
  $("#tiles-are-set").click( function( button ) { return tiles_are_set( this ); } );
  
  // Make the "tiles-are-set" button active
  $("#preview-hands-button").click( function( button ) { return preview_hands( this ); } );
  
  //  Start polling for the opponent state
  get_opponent_state();

{% endblock %}

<!-- 'content' block is placed in base_site.html; override it here to show this content. -->

{% block content %}
  <!-- <br><br>
  <span id="debug">Replace with debug text</span>
  <br> -->

  <!-- player action buttons, down along the left edge. -->
          <div class="pgset-action-buttons pgset-action-buttons-{{ pgtile_size }}">
            <span id="preview-hands"><button id="preview-hands-button" type="button" class="btn btn-mini btn-primary pgset-action-button">Preview Hands</button></span>
            <br><br>
            <span id="tiles-are-set"><button id="tiles-are-set-button" type="button" class="btn btn-mini btn-primary pgset-action-button disabled">Tiles are set</button></span>
          </div>

  <!-- Table of left/right columns, left is your hand, right is the opponent's hand -->
  <table>
    <tr>
        <td width="50%">
          {% show_deal pgsets player %}
        </td>
        <td width="50%">
          {% show_deal pgsets game|opponent_for_game:player %}
        </td>
    </tr>
  </table>


{% endblock %}
