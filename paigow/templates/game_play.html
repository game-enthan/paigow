{% extends "paigow/base_site.html" %}
{% load static %}{% load paigow_extras %}

{% block extra-stylesheet %}
  <link rel="stylesheet" type="text/css" href="{% static "css/pgtile.css" %}" />
{% endblock %}

{% block content_title %}<h1>{{ game.name }}</h1>{% endblock %}

{% block header-javascript %}
  <script language="javascript">

    //  Convenience functions for getting ids etc.
    function set_num_of_button( button )  { return parseInt(button.id.substring(0, 1)); }      // first char

    function set_num_of_set( pgset )
    {
      var parent = $(pgset).parent();
      var jqsets = parent.find(".pgset");
      return jqsets.index( pgset ) + 1;   // 1-based
    }

    function jqset_of_num( set_num )
    {
      var jqdeal = $("#paigow321-deal");
      var jqsets = jqdeal.find(".pgset");
      return $(jqsets[ set_num-1 ] );      // 1-based
      //return $( "#" + set_id_of_num( set_num ) );
    }

    function jqset_of_tile( pgtile ) { return $(pgtile).parent(); }

    function set_num_of_tile( pgtile )  { return set_num_of_set( jqset_of_tile(pgtile)[0] ); }

    function tiles_of_jqset( jqset ) { return jqset.find('.pgtile-div'); }

    function tile_num( pgtile ) { return tiles_of_jqset( jqset_of_tile(pgtile) ).index( pgtile ); }    // index in tile list

    function set_id( pgtile) { return "pgset-div-" + set_num_of_tile( pgtile ); }

    function set_id_of_num( set_num ) { return "pgset-div-" + set_num; }

    function set_class_of_num( set_num ) { return "pgset-{{ pgtile_size }}-" + set_num; }



    //  Switch class and ID convenience.
    function change_class_and_id( jqobj, old_class, new_class, new_id )
    {
        jqobj.removeClass( old_class );
        jqobj.addClass( new_class );
        jqobj.attr( "id", new_id );
    }

    //  Drag/drop convenience functions
    function disable_drop( jqobj )
    {
      jqobj.droppable( {
          disabled: true,
          drop: undefined
        } );
    }

    function drag_tile_start( pgtile, event, ui )
    {
      //  Get the set number from the tile, and make only that set droppable, and
      //  only allow dropping of tiles.
      var jq_set = jqset_of_tile( pgtile );
      jq_set.droppable( {
          disabled: false,
          drop: function(event, ui) { drop_tile( this, event, ui ); }
        } );
      jq_set.data( "orig", $(pgtile).position() );

      //  Put the tile on top of the other tiles.
      $(pgtile).css( "z-index", parseInt($(pgtile).css("z-index")) + 1 );

      //  Add to the droppable the data of the topleft of each of the tiles.
      var lefts = new Array(4);
      var tiles = tiles_of_jqset( jqset_of_tile( pgtile ) );
      var i;
      for ( i = 0; i < 4; i++ )
      {
        lefts[i] = $(tiles[i]).offset().left;
      }
      jq_set.data( "lefts", lefts );
    }
    
    function drag_tile_stop( pgtile, event, ui )
    {
      //  Get the set number from the tile, and undo setting it droppable
      //  and get rid of the drop function.
      var jq_set = jqset_of_tile( pgtile );
      disable_drop( jq_set );
      jq_set.removeData( "lefts" );
      jq_set.removeData( "orig" );

      //  Put the tile in the same plane as the others
      $(pgtile).css( "z-index", parseInt($(pgtile).css("z-index")) - 1 );

    }

    function drop_tile( pgset, event, ui )
    {
      var jqset = $(pgset);

      //  Figure out where the new position is by looking at the lefts array.
      var lefts = jqset.data( "lefts" );

      //  Testing has shown that this is the difference from the original location of the tile.
      var pgtile = ui.draggable[0];
      var source_index = tile_num( pgtile );
      var new_left = ui.offset.left;

      //  Figure out where we should drop it.  There are FIVE possible locations,
      //  from left of the leftmost tile to right of the rightmost tile.  For
      //  moving to the left, only the first four make sense.  For moving to the
      //  right, only the last four make sense.
      var dest_index = 4;
      for ( i = 0; i < 4; i++ )
      {
        if ( new_left < lefts[i] )
        {
          dest_index = i;
          break;
        }
      }

      var orig_dest_index = dest_index;
      var is_moving_left = (dest_index <= source_index);

      //  If we're moving right, then the dest index is actually
      //  one less (zero doesn't make sense, but moving to "1" is
      //  moving to zero).
      if ( !is_moving_left) dest_index--;

      //  If we're not moving it, forget it: returning 'false' will stop the drag.
      if ( dest_index == source_index )
      {
        ui.draggable.animate( {
          left: jqset.data("orig").left, top: jqset.data("orig").top
        } );
        return false;
      }

      //  Re-arrange the tiles for the drop.

      //  Get the number of the tile being dropped, in three loops:
      //  1) calculate the new index for the div
      //  2) reset the positions
      //  3) reset the classes indicating tile number


      //  Calculate the new index for each of the four current tiles.
      new_indices = new Array(4);
      var i;
      for ( i = 0; i < 4; i++ )
      {
        var new_index = i;
        if ( i == source_index )
        {
          //  Is the source tile: move to dest.
          new_index = dest_index;
        }
        else if ( i < dest_index && i < source_index )
        {
          //  To the left of all the action: leave it alone.
        }
        else if ( is_moving_left && (i >= dest_index && i < source_index ))
        {
          //  tile inserted before us: move right (index up)
          new_index = i + 1;
        }
        else if ( is_moving_left )
        {
          //  Must be to right of all the action, leave alone.
        }
        else if ( i <= dest_index && i > source_index )
        {
          //  Moving to the right, between: slide left.
          new_index = i - 1;
        }

        new_indices[i] = new_index;
      }

      //  Move the tiles
      var tiles = tiles_of_jqset( jqset_of_tile( pgtile ) );
      for ( i = 0; i < 4; i++ )
      {
        new_index = new_indices[i];
        $(tiles[i]).animate( {
          left: "" + lefts[new_index] - jqset.offset().left + "px", top: "0px"
        } );
      }

      //  Get the tile and move it, in the DOM, to its place in the list.
      //  We use dest_index to find out if we're moving it to the end
      //  (only moving left), but orig_dest_index to do the final move.
      var jqmoved = $(tiles[source_index]);
      if ( dest_index == 3 )
      {
        jqset.append(jqmoved);
      }
      else
      {
        jqmoved.insertBefore(tiles[orig_dest_index]);
      }

      //  Time to update the labels: send a request to get the new values.
      var new_tiles = tiles_of_jqset( jqset_of_tile( pgtile ) );
      $.ajax( {
        url: "/paigow/hand/",
        context: pgset,
        data: {
            hand: new_tiles[0].getAttribute('tile_id') + 
                  new_tiles[1].getAttribute('tile_id') + 
                  new_tiles[2].getAttribute('tile_id') + 
                  new_tiles[3].getAttribute('tile_id')
                  
//           tile0: new_tiles[0].getAttribute('tile_id'),
//           tile1: new_tiles[1].getAttribute('tile_id'),
//           tile2: new_tiles[2].getAttribute('tile_id'),
//           tile3: new_tiles[3].getAttribute('tile_id')
        },
        success: function( data, textStatus, jqXHR ) { return set_hand_label( this, data, textStatus, jqXHR ); },
        error: function( data, textStatus, jqXHR ) { alert( "Returned error status " + textStatus ); }
      } );
    }

    //  We got a response from our request for the new values for our hands, called
    //  by ajax in drop_tiles above.
    function set_hand_label( context, data, textStatus, jqXHR )
    {
      //  The response is the two labels, with a vertical bar in between.
      var hands = data.split("|");

      //  The context is the set div we were dragging in.
      var set_num = set_num_of_set( context );

      //  Get the labels for this div, and assign by index.
      var labels = $(context).find(".pghand-labels");
      $(labels[0]).text( hands[0] );
      $(labels[1]).text( hands[1] );
    }

    //  Click the up or down button for a set
    function switch_click( button )
    {
      //  Get the set number: it's the first char of the id.
      var source_set_num = set_num_of_button( button );

      //  Get whether we're moving it up or down.
      var dest_set_num = source_set_num + 1

      //  Get the jq objects of the two sets
      var source = jqset_of_num( source_set_num );
      var dest = jqset_of_num( dest_set_num );

      //  Switch the location of the two sets
      var source_top = source.position().top;
      var dest_top = dest.position().top;
      source.animate( { top: dest_top } );
      dest.animate( { top: source_top } );

      //  Reorder the sets within the deal.
      if ( dest_set_num == 3 )     // goes to the end (1-based, remember)
      {
        $(source.parent()).append( source );
      }
      else
      {
        source.insertAfter(dest);
      }

      //  Switch the two sets.
      //  NO: do not do this: we use the set numbers to figure out the tiles in them in drop_tile
      // change_class_and_id( source, set_class_of_num( source_set_num ), set_class_of_num( dest_set_num ), set_id_of_num( dest_set_num ) );
      //change_class_and_id( dest, set_class_of_num( dest_set_num ), set_class_of_num( source_set_num ), set_id_of_num( source_set_num ) );
    }

  </script>
{% endblock %}

{% block jquery-doc-ready %}

  //  Fade the sets in, in order.  These set classes don't have sizes so we can use them as
  //  generic sets.  Note they are 1,2,3 rather than 0-based so the index is the same as
  //  the number of points assigned (for simplicity).
  $("#pgset-div-1").fadeIn( 500);
  $("#pgset-div-2").fadeIn(1000);
  $("#pgset-div-3").fadeIn(1500);
  
  //  The tiles are draggable
  //  TBD: put this in pgtile.html, how to do that while including it several times
  $(".pgtile-div").draggable( {
      //helper: "clone",
      revert: "invalid",
      start: function( event, ui ) { drag_tile_start( this, event, ui ); },
      stop: function( event, ui ) { drag_tile_stop( this, event, ui ); }
    } );

  //  The divs holding the sets will be droppable, but only accept tiles.
  //  They are disabled until a tile is dragged, and only the appropriate
  //  set or sets are un-disabled.
  $(".pgset").droppable( { 
      disabled: true
    } );

  $(".paigow321-deal").droppable( {
      disabled: true
    } );

  $(".pgset-button-switch").click( function( button ) { return switch_click( this ); } );

{% endblock %}

<!-- 'content' block is placed in base_site.html; override it here to show this content. -->

{% block content %}
  <!-- Info about the game -->
  <p class="lead">{{ player }}&nbsp;:&nbsp;&nbsp;<strong>{{ score_you }} - {{ score_opponent }}</strong>&nbsp;:&nbsp;&nbsp;{{ game|opponent_for_game:player }}</p>

  <!-- <br><br>
  <span id="debug">Replace with debug text</span> --?
  <br><br>
  
  <!-- This div shows the 3-set deal -->
  <div id="paigow321-deal-container"  class="paigow321-deal paigow321-deal-{{ pgtile_size }}">
    <div id="paigow321-deal" class="paigow321-deal paigow321-deal-{{ pgtile_size }}">
      <div id="pgset-div-1" class="pgset pgset-{{ pgtile_size }} pgset-{{ pgtile_size }}-1" style="display:none">{% show_pgset pgsets.0 "1" pgtile_size %}</div>
      <div id="pgset-div-2" class="pgset pgset-{{ pgtile_size }} pgset-{{ pgtile_size }}-2" style="display:none">{% show_pgset pgsets.1 "2" pgtile_size %}</div>
      <div id="pgset-div-3" class="pgset pgset-{{ pgtile_size }} pgset-{{ pgtile_size }}-3" style="display:none">{% show_pgset pgsets.2 "3" pgtile_size %}</div>
    </div>
    {% show_switch_button 1 pgtile_size %}
    {% show_switch_button 2 pgtile_size %}
  </div>
{% endblock %}
